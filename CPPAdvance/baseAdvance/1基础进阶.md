# 基础进阶

# const

## 作用

const为类型说明符，可以用来

* 定义常量；  const int a=10;  

  * 常量表达式：值不会改变 并且在<u>编译过程就能得到计算结果</u>的表达式。字面量（不能改变的值）属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

* 类型检查； 

  ```c++
  注意区分 const常量和#define。
  const常量具有类型安全检查功能，#define仅仅是字符串替换
  const 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。
  其他情况下它只是一个 const 限定的变量，不要将其与常量混淆。
  ```

* 防止修改，起到变量保护的作用；

* 节省空间，避免不必要的内存分配。 

  * const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝

## const对象默认文件为局部变量

非const对象变量默认为<font color=red>extern</font>。extern指定的变量，可以跨文件访问。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。

![](./imgs/1const_1.png)

从上述代码可以分析出：

* 未被const修饰的变量不需要extern显式声明。
* 而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。

## 指针与const

```c++
const char * a; //指向const对象的指针或者说指向常量的指针。
char const * a; //同上
char * const a; //指向类型对象的const指针。或者说常指针、const指针。
const char * const a; //指向const对象的const指针。
```

* **指向常量的指针--const char * a**

  ```c++
  const int *ptr;
  *ptr = 10; //error
  ```

  const修饰的是 *ptr， 也即指针ptr指向常量，因此不能修改所指对象的值。

* **非const对象的地址可以赋给指向const对象的指针（指向常量的指针）**

  ```c++
  const int* ptr;
  int val = 3;
  ptr = &val;  //ok
// *ptr =  10; // error
  ```
  
  <font color=red>不能通过ptr指针来修改val的值，即使它指向的是非const对象!</font>

* 常指针

  ```
  int* const p =&a;
  // const 修饰的是指针p，因此，*p可以改变，但是p不能改，即指向某一对象的指针不能改。
  ```

  <font color=red>const指针必须进行初始化，且const指针的值不能修改。</font>

  ![](./imgs/1const_2.png)

### 函数中使用const

1 函数返回值用const修饰，本身无意义

2 const int* f()  指针指向的内容不可改变

3 int* const 指针本身不可变

4 const修饰函数参数（形参）

* ```c++
  void func(const int var)
  void func(int* const pvar) // 常指针
  ```

  上面两种形式本身无意义：首先var本身就是形参，会赋值一份，本身就不会被改变 所以不要加const 修饰。

  pvar为指针，作为形参传入，在函数内也不会被改变。

* <font color=red>参数指针所指内容为常量不可变</font>

  ```c++
  void StringCopy(char *dst, const char *src);
  ```

  其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。

* <font color=red>参数为引用，为了增加效率同时防止修改。</font> 

  ```c++
  void func(const A &a)
  ```

  对于非内部类型来讲，如果使用值传递，效率低（拷贝/赋值等操作），为了提高效率，使用引用来传递参数。但是引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可。

  <font color=red >对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”, 对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。</font>

### 类中使用const

在一个类中，任何不会修改数据成员的函数都应该声明为const类型。使用const关键字进行说明的成员函数，称为<font color=red>常成员函数</font>>。只有常成员函数才有资格操作常量或常对象，没有使用const关键字声明的成员函数不能用来操作常对象。	

* ***对于类中的const成员变量必须通过初始化列表进行初始化。***

![](./imgs/1const_3.png)

* const对象只能访问const成员函数, 而非const对象可以访问任意的成员函数,包括const成员函数.

  ```c++
  class Apple
  {
  private:
      /* data */
      int people[100];
  public:
      Apple(int i);
  
      const int apple_num; // const成员变量
      void take(int num) const;  // 常成员函数
      int add(int num); // 正常函数
      int add(int num) const; // 常成员函数，
      int getCount() const; //常成员函数
      int minus(int num);
  };
  
  Apple::Apple(int i):apple_num(i)
  {
  
  }
  
  void Apple::take(int num) const
  {
      std::cout <<"take const func "<< num << std::endl; 
  }
  int Apple::add(int num)
  {
      std::cout <<"add func " << num << std::endl; 
      take(num);
      return 0;
  }
  int Apple::add(int num) const
  {
      std::cout <<"add const func " << num << std::endl; 
      take(num);
      return 0;
  }
  int Apple::getCount() const
  {
      take(1);
      add(12); 
      return apple_num;
  }
  
  int Apple::minus(int num)
  {
      std::cout <<"minus func " << num << std::endl; 
      take(num);
      return 0;
  }
  ```

  ![](./imgs/1const_4.png)

  由上面结果看到：

  1 const对象默认调用const成员函数。

  2 const对象只能访问const成员函数, 而非const对象可以访问任意的成员函数,包括const成员函数.

* const常量的另外初始化方式

  * 在外面初始化 

    const int Apple::apple_number=10;

  * c++11，直接可以在定义处初始化

    const int apple_number=10;

# static

static与不同的类型使用，具有不同的意义：

* 静态变量：修饰函数中的变量，类中的变量
* 静态类的成员：修饰类对象和类中的函数。

## 静态变量

### 函数中的变量

当一个变量声明为static时，该变量的生命周期位于整个程序周期内，静态变量只分配一次内存，前一次调用中的变量值通过下一次函数调用传递。

```c++
#include <iostream>

void demo()
{
    static int count = 0;
    std::cout << count << std::endl;
    count++;
}
int main()
{

    for (int i = 0; i < 5; i++)
    {
        /* code */
        demo();
    }
    
    return 0;
}
// 输出
0
1
2
3
4
```

由上面代码可以看出：对于函数中的static变量，它的值可以通过函数调用传递。共享。

### 类中的静态变量

static的变量仅被初始化一次，因为再单独的全局内存中的静态内存区域分配了空间，因此**类中的静态变量由对象共享**。 不同的对像不能由相同的静态变量的多个副本，因此：**静态变量不能使用构造函数，需要在类外初始化**

```c++
class Apple
{
public:
    static int i;
    Apple()
    {

    };
};
int Apple::i =10;
int main()
{
    //// 2
    Apple obj1, obj2;
    obj1.i = 1;
    obj2.i = 3;
    std::cout << obj1.i << " " << obj2.i << std::endl;
    return 0;
}
```

如果注释掉：int Apple::i =10; 编译会失败：undefined reference to `Apple::i'

如果有初始化，则输出 3 3

<font color=red>类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化</font>

## 静态类成员

### 类对象为静态

对象也在声明为static时具有范围，直到程序的生命周期。

```c++
class Apple2
{
public:
    int i;
    Apple2()
    {
        i = 0;
        std::cout << "Constructor" << std::endl;
    }
    ~Apple2()
    {
        std::cout << "Destructor" << std::endl;
    }
};

int main()
{
   //// 3 
    { 
        Apple2 obj; 
    } 
    std::cout << "End of main\n"; 
    std::cout << "-------------------\n"; 
    {
        static Apple2 obj1;  
    }
    std::cout << "End of main2\n";
    return 0;
}

/*
输出：
Constructor
Destructor
End of main
-------------------
Constructor
End of main2
Destructor
*/
```

由上面代码可以看出：

<font color=red>如果对象为非static，其对象生命周期仅在声明它的{}范围内，如果是static对象，其生命周期在整个程序内。</font>

### 类中的静态成员函数

类中的静态成员函数也不依赖于类的对象，建议使用：**类名和范围解析运算符调用类的静态成员函数.**

```c++
#include<iostream> 
using namespace std; 

class Apple 
{ 
    public: 
        // static member function 
        static void printMsg() 
        {
            cout<<"Welcome to Apple!"; 
        }
}; 

// main function 
int main() 
{ 
    // invoking a static member function 
    Apple::printMsg(); 
} 
```

# this

c++类中的this指针作用：

* 一个对象的this指针并不是对象的一部分，因此不会影响到sizeof的结果
* this指针声明周期是在类内部，当类的非静态成员函数访问类的非静态成员变量时，编译器会自动将对象本身作为一个隐含参数this传递给函数。
* 类的非静态成员函数若要返回当前对象，直接return *this；
* 赋值时，如果变量名相同：this->n = n;  

## **this会被编译器解析成什么？**

```c++
#include<iostream>
#include<cstring>
#include<stdlib.h>

class Person
{
private:
    /* data */
    int age;
    char* name;
public:
    Person(char* n, int a)
    {
        name = new char[strlen(n)+1];
        strcpy(name, n);
        age = a;
    }
    ~Person()
    {
     delete[] name;   
    }
    int get_age() const{
        return this->age;
    }
    Person& fuc()
    {
        return *this;
    }
};


int main()
{

    Person p("xxx", 10);
    std::cout << p.get_age() << std::endl;
    Person pp = p.fuc();
    return 0;
}
```

在VS下加断点：

![](./imgs/1this_1.png)

![](./imgs/1this_2.png)

<font size=6 color=red>结论：编译器将this 转为：A* const （常指针）</font>

# inline

## 类中内联函数

* 类的函数，如果在声明时，同时也实现了，那就是隐式内联函数。
* 如果头文件只定义，若想在cpp中成为内联函数，必须在实现处(定义处)加inline关键字。

```c++
class A
{
public:
	void f1()
    {
        ... // 隐士内联函数
    }
    void f2();

}


// cpp
inline void A::f2()
{
    // 定义处加inline关键字，推荐这种写法！
}
```

编译器对inline函数的处理是：

1.  将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支

内联函数可以提高效率，但是如果函数体过大，则不宜用内联函数。

另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

## 虚函数可以是内联函数么？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：**编译器知道所调用的对象是哪个类（如 `Base::who()`）**，**这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。**

# sizeof

- [x] 空类的大小为1字节

- [x] 一个类中，虚函数本身/成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间

  ```
  1 静态数据成员被编译器放在程序的一个global data members（全局内存区）中，它是类的一个数据成员，但不影响类的大小。
  
  2 不管这个类产生了多少个实例，还是派生了多少新的类，
  
  3 静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在
  
  4 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小
  ```

- [x] 对于包含虚函数的类，不管有多少个虚函数，也只有一个虚指针vptr的大小

- [x] 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小

- [x] 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！

- [x] 虚继承,继承基类的vptr。

```
 派生类虚继承多个虚函数，会继承所有虚函数的vptr
```

```c++
/*
 * @Author: your name
 * @Date: 2020-05-25 21:28:20
 * @LastEditTime: 2020-05-25 22:04:20
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \vscodeCMakeTmplate\Project\sizeof\sizeof.cpp
 */ 
#include <iostream>

class A
{};

class B
{
    /*
    静态数据成员被编译器放在程序的一个global data members（全局内存区）中，它是类的一个数据成员，但不影响类的大小。
   不管这个类产生了多少个实例，还是派生了多少新的类，
   静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在

   对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小
    */
    public:
    char b;  // 1  
    virtual void fun(){}; // 8字节 
    static int c;
    static int d;
    static int e;
    static int f;
};

class C
{
    public:
    virtual void fun();
    virtual void fun1();
    virtual void fun2();
    virtual void fun3();
};

class D // 公用8
{
    public:
    char a; // 1
    int b; //4
};


/**
此时D1按照顺序：
    char a; // 1
    int b; // 4
    short a; // 2
    long b; // 8

    根据字节对齐： 8 + 8 = 16
 */
class D1 : public D
{
    public:
    short a;
    long b;
};

class E
{
    private:
    D1 a; // 16
    char e; // 1
};

class A1
{
    virtual void fun(){}
};
class C1:public A1
{
};

class A6
{
    virtual void fun() {}
};
class B6
{
    virtual void fun2() {}
};
class C6 : virtual public  A6, virtual public B6  // 虚继承
{
    public:
        virtual void fun3() {}
};

int main()
{
    std::cout << "char: " << sizeof(char) << std::endl; // 1 
    std::cout << "int: " << sizeof(int) << std::endl; // 4
    std::cout << "1: " << sizeof(A) << std::endl;  // 1
    std::cout << "2: " << sizeof(B) << std::endl;  // 16 = 8+8
    std::cout << "3: " << sizeof(C) << std::endl;  // 8
    
    std::cout << "4/5: " << sizeof(D) << std::endl;  // 8
    std::cout << "4/5: " << sizeof(D1) << std::endl;  // 16
    std::cout << "4/5: " << sizeof(E) << std::endl;  //20 = 16+4？

    std::cout << "4/5: " << sizeof(C1) << std::endl;  //8

    std::cout << "6: " << sizeof(A6) << " " << sizeof(B6) << " " << sizeof (C6)<< std::endl;  //8 8 16
    return 0;
}

```

输出：

```
char: 1
int: 4
1: 1
2: 16
3: 8
4/5: 8
4/5: 16
4/5: 20
4/5: 8
6: 8 8 16
```

## 虚继承

多继承（Multiple Inheri[tan](http://c.biancheng.net/ref/tan.html)ce）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突, 如下图：

![](./imgs/1sizeof_1.jpg)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

```c++
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

# 纯虚函数和抽象类

## 纯虚函数

c++中的纯虚函数是没有实现的虚函数，在声明时赋值为0来声明纯虚函数。

## 抽象类

包含纯虚函数的类

抽象类只能作为基类使用，不能实例化。

抽象类的指针和引用 指向 由抽象类派生出来的类的对象。

### 抽象类的实现

<font color=red>抽象类中：在成员函数内可以调用纯虚函数，在构造和析构函数中则不能使用纯虚函数</font>

如果一个类从抽象类派生而来，它必须实现从基类继承的所有纯虚函数，否则还是抽象类。

```c++
#include <iostream>
class A
{
public:
    virtual void f()=0;  // 纯虚函数
    void g() 
    {
        this->f(); //  成员函数内部可以调用纯虚函数
    }
    A(int i)
    {
        //构造函数和析构函数中则不能调用纯虚函数
        //this->f();  // 警告:pure virtual 'virtual void A::f()' called from constructor
        x = i;
    }
protected:
    int x;
};

class B : public A
{
public:
    B(int i, int j):A(i)   // 调用基类构造函数
    {
        y = j;
    }
    void f()
    {
        std::cout << "B: f()" << "x = " << x << " y = " << y << std::endl;
    }
private:
    int y;
};

class A1 : public A
{
    
};
int main()
{
    // 1 纯虚函数使一个类变成抽象类
    //A a; //  error: 不允许使用抽象类类型 "A" 的对象: -- 函数 "A::f" 是纯虚拟函数
    
    // 2 抽象类的指针和引用 可以指向 由抽象类派生出来的类的对象
    A* pa = new B(1, 2);
    pa->f();   // 可以正常输出

    // 3 如果不在派生类中覆盖纯虚函数,那么派生类还是抽象类
    //A1 a1;  // error 不允许使用抽象类类型 "A" 的对象: -- 函数 "A::f" 是纯虚拟函数
    
    // 4 抽象类可以有构造函数
    B bb(12, 34);
    bb.f();
	
    // B b;
    // b.f();

    return 0;
}
```

* <font color=red>构造函数不能是虚函数，而析构函数可以是虚析构函数。</font>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。

# 虚函数表

为了实现虚函数，c++使用了虚表的形式试下后期绑定，该虚表用于解决在动态/后期绑定时用于查找调用函数。 

虚表：<font color=blue>首先每个使用虚函数的类（后者从包含虚函数的类继承）都有自己的虚表。</font>该表只是在编译时设置的静态数组。

<font color=red>虚表包含可由类对象调用的每个虚函数的条目，每个条目只是个函数指针，指向该类可访问的派生函数。</font>

其次，编译器还会添加一个指针vptr，vptr在创建类的实例时自动设置，指向该类的虚表。

![](./imgs/1virtualTable_1.jpg)

```c++
/*
 * @Author: your name
 * @Date: 2020-05-27 22:27:28
 * @LastEditTime: 2020-05-27 22:53:35
 * @LastEditors: Please set LastEditors
 * @Description: 虚函数表  虚函数  多态调用
 * @FilePath: \vscodeCMakeTmplate\Project\vptr_vtable\vptr_vtable.cpp
 */ 
#include <iostream>

class Base
{
public:
    Base() {}  //构造
    virtual void func1()
    {
        std::cout << "Base::func1()" << std::endl;
    }

    virtual void func2()
    {
        std::cout << "Base::func2()" << std::endl;
    }
    virtual void func3()
    {

    }
    ~Base(){};
private:
};


class Derived:public Base
{
public:
    Derived() {};
    ~Derived() {};

    void func1()
    {
        std::cout << "Derived:func1()`" <<std::endl;
    }

    void func2()
    {
        std::cout <<  "Derived::func2()" << std::endl;
    }
};
int main()
{
    Base ptr;
    Derived d;

    Base* pt = new Derived();
    
    std::cout << "基类对象直接调用虚函数" << std::endl;
    ptr.func1();   // 调用的是基类的函数

    std::cout << "基类引用指向基类实例，调用虚函数" << std::endl;
    Base& pp = ptr;  
    pp.func1();   // 调用的是基类的函数

    std::cout<<"基类指针指向派生类实例并调用虚函数"<<std::endl;
    pt->func1();  // 调用的是子类的函数

    std::cout<<"基类引用指向子类实例并调用虚函数"<<std::endl;
    Base& p = d;
    p.func1();   // 调用的是子类的函数

    return 0;    
}
```

# virtual

* 虚函数中的默认参数： **虚函数是动态绑定的，而默认参数是静态绑定的。因此默认参数的使用需要看指针或者引用本身的类型而不是对象的类型。**

    ```c++
    class Base
    {
    public:
        virtual void func(int x = 10)
        {
            std::cout << "Base:func(), x = " << x << std::endl;
        }
    private:
    };
    
    class Derived : public Base
    {
    public:
        virtual void func(int x = 20)
        {
            std::cout << "Derived:func(), x = " << x << std::endl;
        }
    };
    
    int main()
    {
        Derived d;
        Base * pd = &d;  // 父类指针指向子类对象
        pd->func();   // 应该调用的是子类的函数=，打印出20，而实际上打印的10：原因是 默认参数的使用需要看指针或者应用本身的类型，而不是对象的类型！
        return 0;
    }
    ```

* **静态函数不可以声明为虚函数，同时也不能被const和volatile关键字修饰。**

    static成员函数不属于任何类对象，因此加上virtual没有任何意义。

    另外，虚函数vtpr和虚表来执行，vptr为指针，在类中由this指针来访问，而静态成员函数没有this指	针，因此也就无法访问vptr。

    ![](./imgs/1virtual_1.png)

* **构造函数不可以声明为虚函数。同时除了inline之外，构造函数不允许使用其它任何关键字。**

  原因：

  解释1： 尽管虚函数表在编译期间就已经建立，但是指向虚表的vptr直到运行时，实例化对象才会产生。如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。

  每个虚函数都对应虚函数表的以一个条目，利用该条目来调用相应的虚函。每个类都有一个vptr指向虚表，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数

  解释2 ： 虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数

* **析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。** 防止内存泄漏，

* **通常类成员函数都会被编译器考虑是否进行内联。 <u>但通过基类指针或者引用调用的虚函数必定不能被内联。</u> 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。**

  详情见 [inline:虚函数可以是内联函数么？](#虚函数可以是内联函数么？)


# assert

assert是宏，而非函数。#include<assert>

```
void assert(int expression);
```

如果表达式返回错误，则程序终止。 <font color=red>可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前。</font> 

[注]： 括号里面是我们想要的输出结果。

```c++
int x= 9;
assert(x==7);  //引发断言
```

assert主要用于检查逻辑上不可能出现的情况，于正常的错误处理不同，断言通常在运行时被禁用：

```c++
#define NDEBUG   // 需要在程序的最开头
```

# extern "C"

## c++和c编译区别

c++虽然兼容c，但是c++中的函数编译后生成的符号和c生成的不同。因此c++支持重载，因此在生成的符号中带有参数类型信息，而c没有

```c++
c++： int add(int a, int b) ==> 生成类如 add_int_int的形式

c:  int add(int a, intb) ==> 生成 _add的形式
```

这就导致问题：如果在c++中调用c或者c中调用c++，编译连接时可能会找到不到对应的函数符号。

<font color=red>extern "c" 就是解决这样的问题： 告诉编译器，某个函数或者某个文件用c来编译</font>

另外： **<u>extern "c"  在c中时语法错误的，因此都是写在c++的文件中</u>**。



# struct

|                           c                            |                             c++                              |
| :----------------------------------------------------: | :----------------------------------------------------------: |
|                不能将函数放在结构体内部                |                   可以将函数放在结构体内部                   |
|           在C中声明结构体不能使用访问修饰符            |               可以使用 public/private/protated               |
|       在C中定义结构体变量，使用时必须要加struct        |                        可以不加struct                        |
|            结构体不能继承（没有这一概念）。            |                           可以继承                           |
| 若结构体的名字与函数名相同，可以正常运行且正常的调用！ | 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！ |

总结: struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

最本质的区别：就是默认的访问控制

* 默认的继承访问权限。struct 是 public 的，class 是 private 的。

* struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

# union

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

# explicit

* explicit 修饰构造函数时，可以防止隐式转换和复制初始化

* explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

  ```c++
  struct A
  {
      A(int a){}
      operator bool() const {return true;}
  };
  
  struct B
  {
      /* data */
      explicit B(int){}
      explicit operator bool() const { return true; }
  };
  
  
  int main()
  {
      A a1(1);   // 构造函数直接初始化
      A a2 = 1; // 复制初始化
      A a3{1};  // 列表初始化
      A a4 = {1};  // 复制列表初始化
      A a5 = (A)1;  // 允许static_cast的显示转换
      if(a1);   // 使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
      bool a6(a1); //使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
      bool a7 = a1; //使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
      bool a8 = static_cast<bool>(a1); // static_cast直接初始化
  
  
      B b1(1);   // 构造函数直接初始化
      //B b2 = 1; //  被explict修饰的构造函数的对象不可以复制初始化
      B b3{1};  // 列表初始化
      //B b4 = {1};  // 被 explicit 修饰构造函数的对象不可以复制列表初始化
      B b5 = (B)1;  // 允许static_cast的显示转换
      if(b1);   // 使用转换函数 A::operator bool() 的从 A 到 bool 的按语境转换
      bool b6(b1); //使用转换函数 A::operator bool() 的从 A 到 bool 的按语境转换
  
      //bool b7 = b1; //被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
      bool b8 = static_cast<bool>(b1); // static_cast直接初始化
      return 0;
  }
  ```

  ![](./imgs/1explict_1.png)

# friend

友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制

（1）友元函数：普通函数可以访问访问某个类中的**<u>私有或保护成员</u>**。

（2）友元类：类A中的成员函数访问类B中的**<u>私有或保护成员</u>**

提高了代码效率，但是破坏了类的封装性和数据的透明性

* 能访问私有成员 
* 破坏封装性 
* 友元关系不可传递 
*  友元关系的单向性 
* 友元声明的形式及数量不受限制

## 友元函数和友元类

声明在类的任何区域，但是定义则在类的外部。

```
friend <类型><友元函数名>(<参数表>);
```

友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。

因为友元函数没有this指针，则参数要有三种情况： 

- 要访问非static成员时，需要对象做参数；

- 要访问static成员或全局变量时，则不需要对象做参数；

- 如果做参数的对象是全局对象，则不需要对象做参数。
- 可以直接调用友元函数，不需要通过对象或指针

```c++
class A
{
public:
    
    A(int _a):a(_a){}
    friend int geta(A &ca); // 友元函数
    friend int getb();
 
    friend class B; // 友元类
private:
    static int b;
    int a;
};

int A::b = 10;

int geta(A &ca)
{
    return ca.a;
}
int getb()
{
    return A::b;
}


class B
{
public:
    int getb(A ca) {
        return  ca.a; 
    };
};

int main()
{
    A a(3);
    //B b;
    std::cout<<geta(a)<<std::endl; //3
    std::cout<<getb()<<std::endl;// 10

    B b;
    std::cout<<b.getb(a)<<std::endl;// 3
    return 0;
}
```

- 友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。
- 友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。

# using

* using namespace std

* 改变访问属性

  ```
  比如：将基类中的protected可以提升为public，
  ```

  

* 函数重载

  ```
  在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。
  
  在派生类中使用using声明语句指定一个名字而`不指定形参列表`，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。
  ```

  

* 取代typedef取别名：c++11

  ```
  typedef vector<int> V1; 
  using V2 = vector<int>;
  ```

  

```c++

#include <iostream>
#define isNs1 1
//#define isGlobal 2

using namespace std;

    void func()
    {
        cout << "gloabel-->  ::func()" << endl;
    }

namespace s1
{
    void func()
    {
        cout << "s1::func()" << endl;
    }
}


namespace s2
{
#ifdef isNs1 
    using s1::func;    /// ns1中的函数
#elif isGlobal
    using ::func; /// 全局中的函数
#else
    void func() 
    {
        cout<<"other::func"<<endl; 
    }
#endif
}


//2 改变访问性 
// 在类的继承中，即使为private，若使用using，就可以将其访问属性改变为子类的
/**
 * 子类对父类成员的访问权限跟如何继承没有任何关系，
 * “子类可以访问父类的public和protected成员，不可以访问父类的private成员”——这句话对任何一种继承都是成立的。
 *
 */

class Base{
public:
    Base():n(10), val(100){}
    void test1()
    {
        cout << "Base test1() " << endl;
    }
    void test1(int a) // 函数重载
    {
        cout << "Base test1(int a) " << endl;
    }
protected:
    std::size_t n;

private:
    int val;
};
class Derived : private Base { // 私有继承
public:
    void test2()
    {
         cout << "Derived n = " << n << endl;  // n为基类的protected 可以访问，即使是private继承
         //cout << "Derived val = " << val << endl; //  val为私有 不可访问
    }
};

class Derived1 : private Base { // 私有继承
public:
    using Base::n;  // n此时的访问属性为 public
    void test2()
    {
         cout << "Derived n = " << n << endl;  // n为基类的protected 可以访问，即使是private继承
    }
};

// 3 函数重载
class Derived2 : public Base { // public继承
public:
    void test1()
    {
         cout << "Derived2 test1()" << endl;  // n为基类的protected 可以访问，即使是private继承
    }
};

class Derived3 : private Base { 
public:
    using Base::test1;  // 注意不要括号
    void test1()
    {
         cout << "Derived2 test1()" << endl;  // n为基类的protected 可以访问，即使是private继承
    }
};


int main()
{
    s2::func(); // 主要是看 s2中的哪个func函数有效，就使用哪个

    // 2
    Derived d;
    d.test2();
    //d.n;  //成员 "Base::n"  不可访问
    Derived1 d1;
    d1.n = 1000;  // 可以访问

    //3 
    Derived2 d2;
    d2.test1();
    // d2.test1(11); // 不能调用基类中的带参函数，被子类给隐藏掉了
    
    Derived3 d3;
    d3.test1();
    d3.test1(11);  // 可以调用
    return 0;
}
```

# enum

